/* eslint-disable max-len */
/* eslint no-unused-vars: 0 */
const { unflatten, flatten } = require('flat')
const { populator } = require('../utils/populator')
const Filter = require('../utils/filter')
const ViewHelpers = require('../utils/view-helpers')

const PER_PAGE_LIMIT = 500

/**
 * Controller responsible for the autogenerated API: `/admin_root/api/...`, where
 * admin_root is the `rootPath` given in {@link AdminBroOptions}.
 *
 * The best way to utilise it is to use {@link ApiClient} on the frontend.
 *
 * ### Available API endpoints
 *
 * | Endpoint                 | Method                | Description |
 * |--------------------------|-----------------------|-------------|
 * | `.../api/resources/{resourceId}` | {@link ApiController#index} | List of records |
 * | `.../api/resources/{resourceId}/search/{query}` | {@link ApiController#search} | Search record by query string |
 * | `.../api/resources/{resourceId}/actions/{action}` | {@link ApiController#resourceAction} | Perform cusomised resource action |
 * | `.../api/resources/{resourceId}/records/{recordId}/{action}` | {@link ApiController#recordAction} | Perform cusomised record action |
 * | `.../api/dashboard` | {@link ApiController#dashboard} | Perform cusomised dashboard action |
 *
 * @hideconstructor
 */
class ApiController {
  constructor({ admin }, currentAdmin) {
    this._admin = admin
    this.currentAdmin = currentAdmin
  }

  /**
   * @typedef {Object} ApiController~ResourceResponse
   * @property {Array<BaseRecord~JSON>} records
   * @property {Object}                 meta
   * @property {Number}                 meta.page
   * @property {Number}                 meta.perPage
   * @property {String}                 meta.direction
   * @property {String}                 meta.sortBy
   * @property {Number}                 meta.total
   *
   */

  /**
   * Returns paginated list of records for given resource.
   * To call it use {@link ApiClient#getRecords} method.
   *
   * Handler function reponsible for a `.../api/resources/{resourceId}`
   *
   * @param   {Object}  request
   * @param   {Object}  response
   *
   * @return  {ApiController~ResourceResponse}
   */
  async index({ params, query, payload }, response) {
    const { resourceId } = params || {}
    const { sortBy, direction, filters } = unflatten(query || {})
    let { page, perPage } = unflatten(query || {})

    const resource = this._admin.findResource(resourceId)

    const listProperties = resource.decorate().getListProperties()
    const firstProperty = listProperties[0]

    if (perPage) {
      perPage = +perPage > PER_PAGE_LIMIT ? PER_PAGE_LIMIT : +perPage
    } else {
      perPage = 10 // default
    }
    page = Number(page) || 1
    const sort = {
      sortBy: sortBy || firstProperty.name(),
      direction: direction || 'asc',
    }
    const filter = await new Filter(filters, resource).populate()
    const records = await resource.find(filter, {
      limit: perPage,
      offset: (page - 1) * perPage,
      sort,
    })
    let populatedRecords = await populator(records, listProperties)
    populatedRecords = await resource.decorate().recordsDecorator(populatedRecords.map(r => r.toJSON()))

    const total = await resource.count(filter)
    return {
      meta: {
        total,
        perPage,
        page,
        direction: sort.direction,
        sortBy: sort.sortBy,
      },
      records: populatedRecords,
    }
  }

  /**
   * @typedef {Object} ApiController~SearchResponse
   * @property {Array} records
   * @property {String} records[].title
   * @property {String} records[].id
   */

  /**
   * Search records by query string.
   *
   * Handler function reponsible for a `.../api/resources/{resourceId}/search/{query}` route
   *
   * @param   {Object}  request
   * @param   {Object}  response
   *
   * @return  {ApiController~SearchResponse}    found records
   */
  async search(request, response) {
    const queryString = request.params && request.params.query
    const resource = this._admin.findResource(request.params.resourceId)
    const titlePropertyName = resource.decorate().titleProperty().name()

    const filters = queryString ? { [titlePropertyName]: queryString } : {}
    const filter = new Filter(filters, resource)

    const resources = await resource.find(filter, {
      limit: 50,
      sort: {
        sortBy: titlePropertyName,
        direction: 'asc',
      },
    })

    return {
      records: resources.map(res => res.toJSON()),
    }
  }

  /**
   * Returns given record,
   *
   * @param   {Object}  request
   * @param   {Object}  request.params
   * @param   {String}  request.params.resourceId
   * @param   {String}  request.params.recordId
   * @param   {Object}  response
   *
   * @returns {BaseRecord~JSON}
   */
  async get(request, response) {
    const { resourceId, recordId } = request.params || {}
    const resource = this._admin.findResource(resourceId)
    const record = await resource.findOne(recordId)
    const [populated] = await populator([record])

    return {
      record: populated.toJSON(),
    }
  }

  /**
   * Performs a customized {@link Action resource action}.
   * To call it use {@link ApiClient#resourceAction} method.
   *
   * Handler function reponsible for a `.../api/resources/{resourceId}/actions/{action}`
   *
   * @param   {Object}  request
   * @param   {Object}  response
   *
   * @return  {Object}  action response
   */
  async resourceAction(request, response) {
    const { resourceId, action: actionName } = request.params
    const h = new ViewHelpers(this._admin)
    const resource = this._admin.findResource(resourceId)
    const action = resource.decorate().resourceActions()
      .find(a => a.name === actionName)

    return action.handler(request, response, {
      resource, action, h,
    })
  }

  /**
   * Performs a customized {@link Action record action}.
   * To call it use {@link ApiClient#recordAction} method.
   *
   * Handler function reponsible for a `.../api/resources/{resourceId}/records/{recordId}/{action}`
   *
   * @param   {Object}  request
   * @param   {Object}  response
   *
   * @return  {Object}  action response
   */
  async recordAction(request, response) {
    const { resourceId, action: actionName, recordId } = request.params
    const h = new ViewHelpers(this._admin)
    const resource = this._admin.findResource(resourceId)
    const record = await resource.findOne(recordId)
    const action = resource.decorate().recordActions()
      .find(a => a.name === actionName)
    const [populated] = await populator([record])

    return action.handler(request, response, {
      resource, action, h, record: populated,
    })
  }

  /**
   * Gets optional data needed by the dashboard.
   * To call it use {@link ApiClient#dashboard} method.
   *
   * Handler function reponsible for a `.../api/dashboard`
   *
   * @param   {Object}  request
   * @param   {Object}  response
   *
   * @return  {Object}  action response
   */
  async dashboard(request, response) {
    const h = new ViewHelpers(this._admin)
    const handler = this._admin.options.dashboard && this._admin.options.dashboard.handler
    if (handler) {
      return handler(request, response, { h })
    }
    return {
      message: 'You can override this method by setting up dashboard.handler fuction in AdminBro options',
    }
  }
}

module.exports = ApiController
